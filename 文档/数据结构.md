# 数据结构

## 表

### 数组

Java中的数组实现ArrayList的各种操作和数据结构，list的底层是将一个初始值为10的数组通过1.5倍的增长率来进行拓展，我们就可以实现数组的长度可变，即ArrayList

### 链表

**LinkedList** 通过node 和 prev 和 next 三个属性来进行下一个或上一个数组的指定

```java
   private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

```
Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。
```

## HashMap

[HashMap数据结构](https://www.cnblogs.com/yuanblog/p/4441017.html)

[实现原理和遍历方式](http://www.cnblogs.com/constantingF/p/7446307.html)

[HashMap的实现原理和Hash冲突](https://www.cnblogs.com/chengxiao/p/6059914.html)

```java
	Map<String,String> map = new HashMap<>();
	//key为null时只能在map 的首位
	map.put("12", "电影");
	map.put(null, "2332");
	map.put("56", "dffdf");
	for(Map.Entry<String, String> entry:map.entrySet()) {
		System.out.println("键"+entry.getKey()+"值"+entry.getValue());
	}
```





## 树



### B树

#### 2-3树

B树中的所有节点必须在同一层

有两个子节点的节点叫二节点   二节点要么有两个子节点，要么没有子节点

有三个子节点的节点叫三节点。三节点要么有三个节点，要么没有节点

#### 2-3-4树

有两个子节点的节点叫二节点   二节点要么有两个子节点，要么没有子节点

有三个子节点的节点叫三节点。三节点要么有三个节点，要么没有节点

有四个子节点的节点叫四节点。四节点要么有四个节点，要么没有节点

#### B+树

2-3树是3阶的Bs树。 2-3-4树是4阶的B树

非叶子结点都是存储的索引信息，不存储数据

叶子结点的最右边的指针指向下一个相邻的叶结点

B+树和B树的区别就是B+树的非叶子结点存储的是索引信息，但是B树存储的是真正的数据！

二叉树的查找的时间复杂度是 $O(log2N)$，其查找效率与深度有关，而普通的二叉树可能由于内部节点排列问题退化成链表，这样查找效率就会很低。因此平衡二叉树是更好的选择，因为它保持平衡，即通过旋转调整结构保持最小的深度。其查找的时间复杂度也是$O(log2N)$。​

二叉树其受制于深度，深度越深就会使其效率大大降低，所以不适合做为索引！

```
平衡二叉树没能充分利用磁盘预读功能，而B树是为了充分利用磁盘预读功能来而创建的一种数据结构，也就是说B树就是为了作为索引才被发明出来的的。
```

![B树](https://i.imgur.com/b4uxcej.png)

B树

![](https://i.imgur.com/dmhKaRe.png)

B+树 

B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

B+Tree相对于B-Tree有几点不同：

1. 非叶子节点只存储键值信息。
2. 所有叶子节点之间都有一个链指针。
3. 数据记录都存放在叶子节点中。

