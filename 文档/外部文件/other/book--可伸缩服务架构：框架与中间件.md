## 可伸缩服务架构：框架与中间件

---


```

第1章 如何设计一款永不重复的高性能分布式发号器 1

1.1 可选方案及技术选型 2
1.1.1 为什么不用UUID 2
1.1.2 基于数据库的实现方案 2
1.1.3 Snowflake开源项目 3
1.1.4 小结 4

1.2 分布式系统对发号器的基本需求 4

1.3 架构设计与核心要点 6
1.3.1 发布模式 6
1.3.2 ID类型 7
1.3.3 数据结构 7
1.3.4 并发 9
1.3.5 机器ID的分配 9
1.3.6 时间同步 10
1.3.7 设计验证 11

1.4 如何根据设计实现多场景的发号器 11
1.4.1 项目结构 12
1.4.2 服务接口的定义 14
1.4.3 服务接口的实现 15
1.4.4 ID元数据与长整型ID的互相转换 22
1.4.5 时间操作 25
1.4.6 机器ID的生成 27
1.4.7 小结 32

1.5 如何保证性能需求 32
1.5.1 嵌入发布模式的压测结果 33
1.5.2 中心服务器发布模式的压测结果 33
1.5.3 REST发布模式（Netty实现）的压测结果 33
1.5.4 REST发布模式（Spring Boot + Tomcat实现）的压测结果 34
1.5.5 性能测试总结 34

1.6 如何让用户快速使用 35
1.6.1 REST发布模式的使用指南 35
1.6.2 服务化模式的使用指南 38
1.6.3 嵌入发布模式的使用指南 41

1.7 为用户提供API文档 43
1.7.1 RESTful API文档 44
1.7.2 Java API文档 45

第2章 可灵活扩展的消息队列框架的设计与实现 49

2.1 背景介绍 50

2.2 项目目标 50
2.2.1 简单易用 50
2.2.2 高性能 51
2.2.3 高稳定性 51

2.3 架构难点 51
2.3.1 线程模型 51
2.3.2 异常处理 53
2.3.3 优雅关机 53

2.4 设计与实现 54
2.4.1 项目结构 54
2.4.2 项目包的规划 55
2.4.3 生产者的设计与实现 57
2.4.4 消费者的设计与实现 58
2.4.5 启动模块的设计与实现 67
2.4.6 消息处理器的体系结构 76
2.4.7 反射机制 79
2.4.8 模板项目的设计 80

2.5 使用指南 82
2.5.1 安装步骤 82
2.5.2 Java API 83
2.5.3 与Spring环境集成 84
2.5.4 对服务源码进行注解 85

2.6 API简介 87
2.6.1 Producer API 87
2.6.2 Consumer API 88
2.6.3 消息处理器 88
2.6.4 消息处理器定义的注解 90

2.7 消息处理机模板项目 91
2.7.1 快速开发向导 91
2.7.2 后台监控和管理 92

第3章 轻量级的数据库分库分表架构与框架 93

3.1 什么是分库分表 94
3.1.1 使用数据库的三个阶段 94
3.1.2 在什么情况下需要分库分表 95
3.1.3 分库分表的典型实例 96

3.2 三种分而治之的解决方案 97
3.2.1 客户端分片 97
3.2.2 代理分片 100
3.2.3 支持事务的分布式数据库 101

3.3 分库分表的架构设计 102
3.3.1 整体的切分方式 102
3.3.2 水平切分方式的路由过程和分片维度 106
3.3.3 分片后的事务处理机制 107
3.3.4 读写分离 119
3.3.5 分库分表引起的问题 119

3.4 流行代理分片框架Mycat的初体验 123
3.4.1 安装Mycat 123
3.4.2 配置Mycat 124
3.4.3 配置数据库节点 128
3.4.4 数据迁移 129
3.4.5 Mycat支持的分片规则 129

3.5 流行的客户端分片框架Sharding JDBC的初体验 138
3.5.1 Sharding JDBC简介 138
3.5.2 Sharding JDBC的功能 139
3.5.3 Sharding JDBC的使用 141
3.5.4 Sharding JDBC的使用限制 152

3.6 自研客户端分片框架dbsplit的设计、实现与使用 153
3.6.1 项目结构 154
3.6.2 包结构和执行流程 155
3.6.3 切片下标命名策略 159
3.6.4 SQL解析和组装 167
3.6.5 SQL实用程序 168
3.6.6 反射实用程序 173
3.6.7 分片规则的配置 177
3.6.8 支持分片的SplitJdbcTemplate和SimpleSplitJdbcTemplate接口API 179
3.6.9 JdbcTemplate的扩展SimpleJdbcTemplate接口API 184
3.6.10 用于创建分库分表数据库的脚本工具 187
3.6.11 使用dbsplit的一个简单示例 192
3.6.12 使用dbsplit的线上真实示例展示 199

第4章 缓存的本质和缓存使用的优秀实践 201

4.1 使用缓存的目的和问题 202

4.2 自相似，CPU的缓存和系统架构的缓存 203
4.2.1 CPU缓存的架构及性能 205
4.2.2 CPU缓存的运行过程分析 206
4.2.3 缓存行与伪共享 208
4.2.4 从CPU的体系架构到分布式的缓存架构 218

4.3 常用的分布式缓存解决方案 221
4.3.1 常用的分布式缓存的对比 221
4.3.2 Redis初体验 225

4.4 分布式缓存的通用方法 229
4.4.1 缓存编程的具体方法 229
4.4.2 应用层访问缓存的模式 233
4.4.3 分布式缓存分片的三种模式 235
4.4.4 分布式缓存的迁移方案 238
4.4.5 缓存穿透、缓存并发和缓存雪崩 244
4.4.6 缓存对事务的支持 246

4.5 分布式缓存的设计与案例 248
4.5.1 缓存设计的核心要素 248
4.5.2 缓存设计的优秀实践 250
4.5.3 关于常见的缓存线上问题的案例 253

4.6 客户端缓存分片框架redic的设计与实现 257
4.6.1 什么时候需要redic 258
4.6.2 如何使用redic 258
4.6.3 更多的配置 258
4.6.4 项目结构 260
4.6.5 包结构 261
4.6.6 设计与实现的过程 261

第5章 大数据利器之Elasticsearch 268

5.1 Lucene简介 269
5.1.1 核心模块 269
5.1.2 核心术语 270
5.1.3 检索方式 271
5.1.4 分段存储 273
5.1.5 段合并策略 275
5.1.6 Lucene相似度打分 278

5.2 Elasticsearch简介 286
5.2.1 核心概念 286
5.2.2 3C和脑裂 289
5.2.3 事务日志 291
5.2.4 在集群中写索引 294
5.2.5 集群中的查询流程 295

5.3 Elasticsearch实战 298
5.3.1 Elasticsearch的配置说明 298
5.3.2 常用的接口 300

5.4 性能调优 305
5.4.1 写优化 305
5.4.2 读优化 308
5.4.3 堆大小的设置 313
5.4.4 服务器配置的选择 315
5.4.5 硬盘的选择和设置 316
5.4.6 接入方式 318
5.4.7 角色隔离和脑裂 319

第6章 全面揭秘分布式定时任务 321

6.1 什么是定时任务 322

6.2 分布式定时任务 341
6.2.1 定时任务的使用场景 342
6.2.2 传统定时任务存在的问题 342
6.2.3 分布式定时任务及其原理 344

6.3 开源分布式定时任务的用法 347
6.3.1 Quartz的分布式模式 347
6.3.2 TBSchedule 356
6.3.3 Elastic-Job 365

第7章 RPC服务的发展历程和对比分析 377

7.1 什么是RPC服务 378

7.2 RPC服务的原理 379
7.2.1 Sokcet套接字 379
7.2.2 RPC的调用过程 380

7.3 在程序中使用RPC服务 382

7.4 RPC服务的发展历程 383
7.4.1 第一代RPC：以ONC RPC和DCE RPC为代表的函数式RPC 384
7.4.2 第二代RPC：支持面对象的编程 388
7.4.3 第三代RPC：SOA和微服务 398
7.4.4 架构的演进 402

7.5 主流的RPC框架 403
7.5.1 Thrift 403
7.5.2 ZeroC Ice 410
7.5.3 gRPC 418
7.5.4 Dubbo 430

第8章 Dubbo实战及源码分析 436

8.1 Dubbo的四种配置方式 437
8.1.1 XML配置 437
8.1.2 属性配置 440
8.1.3 API配置 441
8.1.4 注解配置 443

8.2 服务的注册与发现 446
8.2.1 注册中心 446
8.2.2 服务暴露 449
8.2.3 引用服务 451

8.3 Dubbo通信协议及序列化探讨 455
8.3.1 Dubbo支持的协议 455
8.3.2 协议的配置方法 456
8.3.3 多协议暴露服务 457
8.3.4 Dubbo协议的使用注意事项 458
8.3.5 Dubbo协议的约束 459

8.4 Dubbo中高效的I/O线程模型 459
8.4.1 对Dubbo中I/O模型的分析 459
8.4.2 Dubbo中线程配置的相关参数 460
8.4.3 在Dubbo线程方面踩过的坑 461
8.4.4 对Dubbo中线程使用的建议 462

8.5 集群的容错机制与负载均衡 462
8.5.1 集群容错机制的原理 462
8.5.2 集群容错模式的配置方法 464
8.5.3 六种集群容错模式 464
8.5.4 集群的负载均衡 465

8.6 监控和运维实践 467
8.6.1 日志适配 467
8.6.2 监控管理后台 467
8.6.3 服务降级 473
8.6.4 优雅停机 475
8.6.5 灰度发布 475

8.7 Dubbo项目线上案例解析 477
8.7.1 线上问题的通用解决方案 477
8.7.2 耗时服务耗尽了线程池的案例 480
8.7.3 容错重试机制引发服务雪崩的案例 481

8.8 深入剖析Dubbo源码及其实现 483
8.8.1 Dubbo的总体架构设计 483
8.8.2 配置文件 486
8.8.3 Dubbo的核心RPC 488
8.8.4 Dubbo巧妙的URL总线设计 491
8.8.5 Dubbo的扩展点加载SPI 492
8.8.6 Dubbo服务暴露的过程 493
8.8.7 服务引用 502
8.8.8 集群容错和负载均衡 503
8.8.9 集群容错 504
8.8.10 负载均衡 509

第9章 高性能网络中间件 512

9.1 TCP/UDP的核心原理及本质探索 513
9.1.1 网络模型 513
9.1.2 UDP、IP及其未解决的问题 515
9.1.3 TCP详解 519
9.1.4 是否可以用UDP代替TCP 527
9.1.5 网络通信的不可靠性讨论 529

9.2 网络测试优秀实践 530
9.2.1 网络测试的关键点 530
9.2.2 那些必不可少的网络测试工具 532
9.2.3 典型的测试报告 539

9.3 高性能网络框架的设计与实现 544
9.3.1 对代理功能的测试及分析 545
9.3.2 网络中间件的使用介绍 549
9.3.3 内存和缓存的优化 551
9.3.4 快速解析流数据 554

```